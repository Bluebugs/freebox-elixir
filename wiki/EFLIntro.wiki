#summary Présentation rapide de tous les composants des bibliothèques du projet Enlightenment.

= Introduction =

Ce document présente succinctement les bibliothèques du projet Enlightenment. 
Il se base sur les documents suivants [http://fr.enlightenment.org/wiki/wiki/] et mes connaissances personnelles sur le sujet.

= Bref historique =

Retour en 1999: le gestionnaire de fenêtres Enlightenment (version 16), très en avance sur son temps, offre une interface utilisateur très "eye-cadies", tout en conservant la convivialité.

Plusieurs effets graphiques (fenêtres coulissantes, animation d'ombrage, et the ripples and waves ) ont été tout à fait révolutionnaire pour un gestionnaire de fenêtre. Avec la possibilité de rajouter différents thèmes.

Alors que la plupart des applications, suportant le principe du thème ne permet que de modifier la couleur des interfaces, Enlightenment pouvait personnaliser tout.
Les thèmes pourraient être complètement différents suivant l'aspect que l'on regarde. Plusieurs thèmes ont été tellement complexe que finalement faire des Enlightenment ressemble à différents systèmes (Mac OS Aqua, BeOS).

Enlightenment a aussi été à un moment intégré à Gnome. Alors que Gnome a progressé depuis et vient maintenant avec son propre gestionnaire de fenêtres (Metacity), le fait est que Enlightenment a été installé sur de nombreux ordinateurs de bureau à l'époque. La version 16 est toujours la dernière version stable d'Enlightenment. Cela signifie que Enlightenment V16 est un gestionnaire de fenêtres très stable. Depuis ses besoins en ressources sont à peu près les même, ce qui semble être un poids lourd des gestionnaires de fenêtres se révèle être très léger.

Alors, pourquoi n'avons-nous pas une nouvelle version d'Enlightenment aujourd'hui? Et pourquoi la version de développement (V17) n'a pas encore été sortie en version stable, après tant d'années ?

La version 17 de Enlightenment est un "desktop shell". L'infrastructure de ce window manager se présente sous la forme de bibliothèques graphiques distinct appelé "Enlightenment Foundation Libraries"(*EFL* en plus court). Enlightenment est maintenant basé sur ces bibliothèques, qui peut également être utilisé pour des applications normales en dehors du gestionnaire de fenêtres.

Ces bibliothèques qui se devait d'être efficace en utilisant aux mieux le matériel quelque soit les conditions, se sont révélé être tout a fait utilisable pour l'écriture d'applications généraliste. Permettant même d'écrire des applications plus graphique sans avoir besoin d'une machine de dernière génération. Ces bibliotheques arrivant à tirer le meilleur du matériel, elles sont naturellement utilisée dans des projets embarqués avec du matériel beaucoup plus limité que nos PC de bureau.

Ainsi les projets suivant utilisent les EFL :
  * [http://openbossa.indt.org/canola/ Canola] (Nokia N810)
  * [http://wiki.openmoko.org/wiki/Main_Page OpenMoko]
  * [http://openinkpot.org/ OpenInkpot] (e-book)
  * [http://geexbox.org/en/index.html GeexBox] (lecteur multimédia)
  * [http://www.calaos.fr/cms/index.php Calaos] (solution domotique)

= Les bibliothèques ==

Cette introduction se concentrera sur les bibliothèques utilisé et nécessaire pour Elixir.

== Eina ==

Cette bibliothèque fournit un ensemble de type de données avec un rapport performance/consommation mémoire le plus efficace possible. Elle est utilisé par tout le projet Enlightenment et par Elixir pour leur type de données. Mais l'interface JavaScript d'Elixir n'expose aucune de ses fonctions, car le JavaScript inclue deja tous les types de données utiles (tableau, table de hashage, liste, ...).

Cette bibliothèque n'a donc d'utilité que pour les developpeurs C des EFL.

[http://docs.enlightenment.org/api/eina/html/ Documentation]

== Eet ==

Cette bibliothèque fournit des *outils de sérialisation des données* nécessaire pour les EFL. Elle permet ainsi de sauvegarder dans un unique fichier des images et des objets qui peuvent être relu quelque soit la plateforme. Elle permet aussi de sérialiser/désérialiser des objets rapidement pour les envoyer sur le réseau.

Cette bibliothèque aura principalement son utilité avec Edje (voir ci-dessous) et lors de transfert réseau. Une partie de l'API de eet est donc disponible dans Elixir pour gérer la sérialisation réseau.

[http://docs.enlightenment.org/api/eet/html/ Documentation]

== Evas ==

Cette bibliothèque fourni un *canvas state-full*. C'est cette bibliotheque qui expose des méthodes pour créer et manipuler des objets graphiques. C'est elle qui optimise le rendu pour tirer le maximum du matériel quel a à disposition.

Cette bibliothèque est la base graphique de tout le pipeline de rendu des EFL. Ces API permettent de créer des primitives graphiques (Image, Rectangle, Text, ...) et de les manipuler. Elle s'occupe aussi du dispatching des events aux bons objets. Etant le coeur graphique des EFL, son API est bien entendu accessible en JavaScript avec quelque légère différence avec l'API C.

[http://docs.enlightenment.org/api/evas/html/ Documentation]

== Ecore ==

Cette bibliothèque gère toute la partie *évenementielle* des EFL avec notament des timers, la gestion du réseau, l'accès aux système de fichiers, mais aussi la création de fenètre.

Le binding JavaScript expose partiellement l'API C d'Ecore. Ainsi seul les timers, la gestion réseau et la gestion de fenètre sont éxposé.

[http://docs.enlightenment.org/api/ecore/html/ Documentation]

== Edje ==

C'est LA bibliothèque des EFLs. Elle permet de définir des interfaces utilisateurs complètement séparées du code des développeurs. Le graphiste peut alors définir son interface sans être lié aux contraintes du développeurs et vice versa. C'est ici que sont défini les effets graphiques/animations à effectuer. Edje utilise Eet pour stocker ses données, Evas pour manipuler les objets définit par les graphistes et Ecore pour gérer le temps.

Le binding JavaScript se veut aussi complet que possible étant donnée l'importance de cette bibliothèque dans tout projet utilisant les EFL et les différences avec l'API C sont mineure.