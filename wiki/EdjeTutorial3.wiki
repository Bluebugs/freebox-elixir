#summary Tutorial présentant Edje.

= Note =

Merci a Raoul Hecky pour ce tutoriel initialement publié sur son [http://blog.calaos.fr blog].

= Application Flickr ==

Dans la petite série d’articles sur les Efl, voici la première partie qui explique la création d’une petite application utilisant les EFL. Il s’agit d’une simple interface qui va permettre d’afficher des photos en provenance d'un site web de Photo et les faire défiler sous forme de slideshow. On donnera aussi la possibilité à l’utilisateur d’interagir avec l’interface et mettre la photo en plein écran ou encore passer à l’image suivante. Ce tutorial se concentrera sur le design de l’interface grâce à Edje.

Afin de créer notre petite interface, nous allons d’abord créer les différentes images, pour cela on pourra se servir d’un logiciel tels que Gimp ou Inkscape. Dans le cas présent j’ai utilisé Inkscape pour faire un fond du type « _photo polaroid_ »:

[http://freebox-elixir.googlecode.com/svn/trunk/exemples/edje/tutorial_03/images/picture_back.png]

Cela nous donne le fond de l’interface. Pour les controles (plein écran et Image suivante) on va ajouter un petit « _overlay_ » en bas de l’image qui sera affiché lorsque la souris passe sur la photo.

[http://freebox-elixir.googlecode.com/svn/trunk/exemples/edje/tutorial_03/images/logo.png]

Afin d’agrémenter l’interface d’animations inutiles, on va ajouter un « _splash screen_ » lors du démarrage de l’application. Ce sera un logo qui s’affichera au milieu de l’interface et disparaitra progressivement.

[http://freebox-elixir.googlecode.com/svn/trunk/exemples/edje/tutorial_03/images/back03.png]

Il ne nous reste plus qu’à découper les différentes parties: le fond, l’overlay, le bouton fullscreen, le bouton suivant et pour finir le logo.

Nous avons maintenans toutes les ressources qu’ils nous faut pour écrire le fichier edje. Commençons par déclarer les images qui seront utilisées:

{{{
images
{
        image: "picture_back.png" COMP;
        image: "logo.png" COMP;
        image: "controls_back.png" COMP;
        image: "control_fs.png" COMP;
        image: "control_next.png" COMP;
        image: "transition_vswipe_gap.png" COMP;
}
}}}

Puis le group principal chargé par l’application. On donnera une taille minimum et maximum à ce group:

{{{
group
{
        name: "widget/picture";
        min: 200 191;
        max: 600 600;
}}}

Continuons maintenant par le fond de l’interface (_picture`_`back.png_):

{{{
part
{
        name: "back";
        description
        {
                state: "default" 0.0;
                image.normal: "picture_back.png";
                image.border: 99 100 94 96;
        }
}
}}}

On definit également le paramètre border de l’image, pour permettre au fond de se redimensionner mais en gardant les bords intacts.
On continue par ajouter le conteneur de type *SWALLOW* qui servira a accueillir la photo elle même:

{{{
part
{
        name: "picture";
        type: SWALLOW;
        clip_to: "picture_clip";
        description
        {
                state: "default" 0.0;
                rel1 { relative: 0.0 0.0; offset: 8 8; }
                rel2 { relative: 1.0 1.0; offset: -21 -35; }
        }
}
}}}

Nous pouvons passer maintenant au texte qui affichera le titre de la photo ainsi que la partie des controles.

{{{
part
{
        name: "title";
        type: TEXT;
        description
        {
                state: "default" 0.0;
                visible: 1;
                color: 12 12 12 200;
                rel1 { relative: 0.0 1.0; offset: 8 -33; }
                rel2 { relative: 1.0 1.0; offset: -21 -16; }
                text { text: "..."; font: "CalaosContent"; size: 10; align: 0.0 0.5;}
        }
}
}}}

Le texte utilisera la police définit au debut du fichier et sera aligné horizontalement sur la gauche, et centré verticalement (_align_: *0.0 0.5*;) Pour les controles, nous allons utiliser un clip qui servira a afficher/cacher la barre de controles. Ce rectangle ne sera pas directement visible, mais les parties clippé a ce rectangle prendront les memes propriétés de couleur. On donne donc 2 etats a ce rectangle et on s’en servira pour faire un fondu entre l’etat affiché et l’etat caché.

{{{
part
{
        name: "controls";
        type: RECT;
        description
        {
                state: "default" 0.0;
                rel1 { relative: 0.0 1.0; offset: 0 -90; }
                rel2 { relative: 1.0 1.0; offset: -1 -1; }
                color: 255 255 255 0;
                visible: 0;
        }
        description
        {
                state: "visible" 0.0;
                inherit: "default" 0.0;
                color: 255 255 255 255;
                visible: 1;
        }
}
part
{
        name: "controls_back";
        clip_to: "controls";
        description
        {
                state: "default" 0.0;
                image.normal: "controls_back.png";
                image.border: 4 4 4 4;
                rel1 { relative: 0.0 1.0; offset: 14 -79; }
                rel2 { relative: 1.0 1.0; offset: -26 -39; }
        }
}
}}}

La barre de controles ainsi que les boutons seront clippé par rapport a l’element « _controls_ » (_clip`_`to_: « _controls_ »;). La meme technique sera utilisé pour l’affichage du splash screen (le logo).

Nous avons maintenant un design d’interface definit dans notre edc. Il reste maintenant la partie animation et les différents « _programs_ » qui donneront de la vie. Nous allons commencer par afficher le splash screen au demarrage de l’application. Pour cela rien de plus simple, il faut mettre le clip du logo dans l’etat visible avec une transition et le tout s’execute au moment ou l’edje est affiché (evennement show):

{{{
program
{
        name: "on_show";
        signal: "show";
        source: "";
        action: STATE_SET "visible" 0.0;
        transition: SINUSOIDAL 4.0;
        target: "logo_splash";
        after: "hide_splash";
}
}}}

Puis pour cacher le splash apres qu’il ai été affiché, on lance after: « _hide`_`splash_ »; qui va remettre le logo dans son etat « _default_ » initial, donc invisible. On utilisera une technique similaire pour afficher/cacher la barre de controles, a la difference pres que la barre s’affichera lorsque la souris sera sur la fenetre de notre application:

{{{
program
{
        name: "on_mouse_in";
        signal: "mouse,in";
        source: "mouse_mask";
        action: STATE_SET "visible" 0.0;
        transition: ACCELERATE 0.23;
        target: "controls";
}
program
{
        name: "on_mouse_out";
        signal: "mouse,out";
        source: "mouse_mask";
        action: STATE_SET "default" 0.0;
        transition: DECELERATE 0.75;
        target: "controls";
}
}}}

L’evenement « _mouse,in_ » et « _mouse,out_ » seront utilisés pour determiner si la souris entre ou sort de l’interface. Il nous reste encore a envoyer les signaux à l’application lorsque l’on clique sur les boutons fullscreen et suivant.

{{{
program
{
        name: "on_click_fs";
        signal: "mouse,clicked,1";
        source: "button_fs";
        action: SIGNAL_EMIT "fullscreen" "controls";
}
}}}

Pour le bouton plein ecran on enverra le signal « _fullscreen_ » avec comme source « _controls_ ». L’application devra réagir à ce signal, nous laisserons ca à un prochain article.

Nous voila donc avec une interface fonctionnelle et prête a etre intégré dans l’application qui reste encore a ecrire. Les sources edje complete sont disponible [http://code.google.com/p/freebox-elixir/source/browse/trunk/exemples/edje/tutorial_03/ ici].